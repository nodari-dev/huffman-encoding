package main

import (
	"fmt"
)

type Node struct {
	freq int
	char byte
	left *Node
	right *Node
}

type MinHeap struct{
	arr []Node
}

func (mh *MinHeap) swap(i, j int){
	(*mh).arr[i], (*mh).arr[j] = (*mh).arr[j], (*mh).arr[i]
}

func (mh *MinHeap) insert(node Node){
	if len(mh.arr) == 0{
		mh.arr = append(mh.arr, node)
		return
	}
	mh.arr = append(mh.arr, node)
	heapify_up(&mh.arr, len(mh.arr) - 1)
}

// left child (i * 2) + 1
// right child (i * 2) + 2
// parent (i - 1) / 2

func heapify_up(arr *[]Node, index int){
	if index == 0{
		return
	}

	current := (*arr)[index]
	parentIdx := (index - 1) / 2
	parent := (*arr)[parentIdx]

	if parent.freq > current.freq {
		(*arr)[parentIdx] = current
		(*arr)[index] = parent
		heapify_up(arr, parentIdx)
	}
}

// replace root or element which needs to be deleted with the last element
func (mh *MinHeap) remove_by_index(index int) (Node, bool){
	lenght := len((*mh).arr)
	if index > len(mh.arr) || index < 0{
		return Node{}, false
	}

	mh.swap(0, lenght - 1)

	result := (*mh).arr[lenght - 1]
	(*mh).arr = (*mh).arr[:lenght - 1]

	mh.heapify_down(0)

	return result, true
}

func (mh *MinHeap) heapify_down(index int) {
	lIdx := (index * 2) + 1
	rIdx := (index * 2) + 2

	if len(mh.arr) == 2{
		c := (*mh).arr[index]
		l := (*mh).arr[lIdx]
		if l.freq < c.freq {
			mh.swap(lIdx, index)
		}
	}
	if index > len(mh.arr) - 1 || lIdx >=len((*mh).arr) - 1  {
		return
	}
	// WE NEED TO REPLACE WITH THE SMALLEST CHILD

	c := (*mh).arr[index]
	l := (*mh).arr[lIdx]
	r := (*mh).arr[rIdx]

	if l.freq > r.freq && c.freq > r.freq {
		mh.swap(rIdx, index)
		mh.heapify_down(rIdx)
	}
	if r.freq > l.freq && c.freq > l.freq {
		mh.swap(lIdx, index)
		mh.heapify_down(lIdx)
	}
	if l.freq == r.freq && c.freq > r.freq{
		mh.swap(lIdx, index)
		mh.heapify_down(lIdx)
	}
}

func huffman_encoding_shenanigans(minheap *MinHeap){
	for len(minheap.arr) > 1{
		left_node, _ := minheap.remove_by_index(0)
		// fmt.Printf("LN -> %d %c\n", left_node.freq, left_node.char)
		right_node, _ := minheap.remove_by_index(0)
		// fmt.Printf("RN -> %d %c\n", right_node.freq, right_node.char)

		new_node := Node{freq: left_node.freq + right_node.freq, left: &left_node, right: &right_node}
		minheap.insert(new_node)
	}
}

func generate_huffman_table(
	node *Node,
	arr[]int,
	byte_count int,
	b byte,
	huffman_table *map[byte]Huffman_table_item,
){

	// if we are traversing the tree and byte_count > 8
	// we need to add full byte to arr
	// then create a new byte 
	// fill it and add to arr
	// repeat until char is found

	// TODO: take care of byte count
	if node.left == nil && node.right == nil {
		_, ok := (*huffman_table)[node.char]
		if ok {
			// append completed byte to byte arr
			entry := (*huffman_table)[node.char]
			entry.b_arr = append(entry.b_arr, b)
			entry.bits_to_read += byte_count
			(*huffman_table)[node.char] = entry
		} else {
			(*huffman_table)[node.char] = Huffman_table_item{b_arr: []byte{b}, bits_to_read: byte_count}
		}
		// fmt.Printf("Bits: %08b for %c\n",b,node.char)
		b = 0
		byte_count = 0

		return 
	}

	if byte_count > 8{
		// append completed byte to byte arr
		entry := (*huffman_table)[node.char]
		entry.b_arr = append(entry.b_arr, b)
		entry.bits_to_read += byte_count
		(*huffman_table)[node.char] = entry
		b = 0
		byte_count = 0
	}

	byte_count += 1
	// shift left
	b <<= 1

	if node.left != nil {
		new_arr := arr
		new_arr = append(arr, 0)
		generate_huffman_table(node.left, new_arr, byte_count, b, huffman_table)
	}

	if node.right != nil {
		new_arr := arr
		new_arr = append(arr, 1)
		// if right leave then use OR operator and set 1
		b |= 1
		generate_huffman_table(node.right, new_arr, byte_count, b, huffman_table)
	}
}

func show_minheap(arr *[]Node){
	for i:= range (*arr){
		fmt.Printf("%c %d", (*arr)[i].char, (*arr)[i].freq)
	}
	fmt.Print("\n")
}


type Huffman_table_item struct{
	b_arr []byte
	bits_to_read int
}

func main(){
	hashmap := make(map[byte]int)
	test := "big boobas"
	// test := "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam luctus varius imperdiet. Phasellus a dui enim. Proin consequat ante eget euismod semper. Maecenas non pellentesque felis."
	for i := range test{ 
		hashmap[test[i]] += 1
	}

	minheap := MinHeap{}
	for key, value := range hashmap{
		minheap.insert(Node{freq: value, char: key})
	}
	huffman_encoding_shenanigans(&minheap)

	// later I need to allow to store byte arr
	// huffman_table := make(map[byte]byte)
	huffman_table := make(map[byte]Huffman_table_item)
	test_arr := []int{}
	generate_huffman_table(&minheap.arr[0], test_arr, 0, byte(0), &huffman_table)

	// for i := range huffman_table{
	// 	fmt.Printf("%c %d and %v\n", i, huffman_table[i].bits_to_read, huffman_table[i].b_arr)
	// }


	// result := []byte{}
	// for char := range test{
	// 	bits_to_read := huffman_table[byte(char)].bits_to_read
	// 	b_arr := huffman_table[byte(char)].b_arr
	// 	// do count down
	// 	bits_read := bits_to_read
	// 	bits_left_to_fill := 0
	//
	// 	if bits_to_read > 8{
	// 		// array of 2+ bytes
	// 	}
	//
	// 	if bits_to_read == 8{
	// 		// array of one full byte
	// 	}
	//
	// 	}
	// } 


	resut := []int{0b00001111}
	bits_available_to_fill := uint16(4)

	fmt.Printf("Before: %08b\n", resut[0])

	// from_arr := []int{0b11110101} 
	// index_from := 0
	total_bits_left_to_move := uint16(8)
	// index_to := 0
	// bits_moved := 0
	// selected_bits := 0b00000000
	// for char_indx := range test{
	// 	huffman_table_item := huffman_table[test[char_indx]]
	// }

	// for index_from != len(from_arr) - 1{
	// 	if available_bits_space == 0{
	// 		// filled the byte
	// 		// move to the next
	// 		resut = append(resut, 0b00000000)
	// 		index_to += 1
	// 		available_bits_space = 8
	// 	}
	//
	// 	if bits_moved == 8{
	// 		index_from += 1
	// 		bits_moved = 0
	// 	}
	// 	
	// 	if available_bits_space != 8{
	// 		// move only when we filled some poriton of byte
	// 		// do move left by available_bits_space
	// 		resut[index_to] <<= available_bits_space
	// 	}
	// 	
	// 	if bits_left_to_move < available_bits_space{
	// 		selected_bits = from_arr[index_from] >> (8 - available_bits_space)
	// 		resut[index_to] = resut[index_to] | selected_bits
	// 	}
	//
	// 	if bits_left_to_move > 8 && bits_left_to_move > available_bits_space{
	// 	}
	//
	// 	if bits_left_to_move > available_bits_space {
	// 		// selected_bits = from_arr[index_from] >> (8 - available_bits_space - bits_left_to_move)
	// 		resut[index_to] = resut[index_to] | selected_bits
	// 	}
	//
	// 	if bits_left_to_move == 0 {
	// 		// this char is done
	// 		// move to the next one
	// 	}
	//
	// }
	
	// fmt.Printf("From: %08b\n", from)

	from_list := []int{0b11101101, 0b010011000}
	to_list := []byte{0b00001011}
	to_list_index := 0

	bits_available_to_fill = 4
	total_bits_left_to_move = 13

	temporary_from := from_list[0]

	for total_bits_left_to_move > 0{

		fmt.Printf("From: %08b\n", from_list[0])
		if total_bits_left_to_move > 8
		if bits_available_to_fill != 8{
			// MAYBE IS SHOULD REMOVE IF
			to_list[to_list_index] <<= bits_available_to_fill
		}


		// if bits_left_to_move == 8 {
		// 	//
		// }

		if total_bits_left_to_move < bits_available_to_fill{

		}

		if total_bits_left_to_move != 8 && total_bits_left_to_move > bits_available_to_fill{
			mask := get_bit_mask(int(bits_available_to_fill))
			fmt.Printf("Mask: %08b \n", mask)

			temporary_from &= mask
			fmt.Printf("From with mask: %08b\n", temporary_from)

			// important part
			total_bits_left_to_move -= bits_available_to_fill
		}


		// fmt.Printf("Selected: %08b\n", selected_bits)
		resut[0] <<= bits_available_to_fill
		resut[0] |= temporary_from

		// IMPORTANT
		// if I set last bits and its the byte to get bits from I need to move bits anyway
		fmt.Printf("Result: %08b\n", resut[0])
	}


	// create a huffman tree from the string
	// create a huffman table 
	// use table for encding a string
	
	// send chars in descending order
	// send freqs in descending order
	// send encoded value

	// generate a tree
	// decode value by using the tree
}

func get_bit_mask(number_of_used_bits int) int{
	return 255 >> (8 - number_of_used_bits)
}
